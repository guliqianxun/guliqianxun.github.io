## 通信详谈

在工作中，新手常常遇到各种串口相互转换，通信协议，物理串口，电气标准傻傻分不清的情况，这里就开始大体介绍一下他们的区别。

### 通信的理解

通信的本质是信息的交互，如果要实现通信，就需要有交互目标、手段和内容。

### 一：交互目标

从整体层面来看，大体可以分为：*人人交互*，*人机交互*，*机器之间的交互*，他们因为各自的不同，在设计交互手段的内容和手段时侧重点便也不同。

这里拿人和人之间的交流举例——在中国，人和人之间大都会普通话，因此交流往往以普通话为主要手段，但是在面对小孩和外国人时，肢体语言和象形文字就成了主要手段了。因此，在设计时明确交互的目标是十分重要的，它直接限制了手段和内容——需要使用彼此都能够理解的手段，转化后能够被理解的内容。

下面主要将目标放在机器之间，因为人为参与的原因，在设计机器之间信息交互的时候，也会考虑到人的因素。

### 二、交互手段

有线和无线

有线的载体：光、电······

#### 串行通信和并行通信

##### 1.1并行通信

所谓的并行通信，就是一次发多个数据位，在一个时钟周期内，有多个数据位同时传输啦，这个数据位的多少，就看你有多少根数据线楼，这种传输方式的控制，一般由别的引脚负责，有单独的读写使能引脚。

这种通信方式适合于近距离的通信，其传输中有多个数据位，同时在两个设备之间传输。计算机内的总线结构就是并行通信的例子。

<img src="..\imgs\并行通信.gif"  alt="并行通信" />

图1.1 并行通信
**优点**

>- 传输速度快，信息率高。
>
>
>- 适合于外部设备与微机之间进行大量和快速的信息交换。
>
>
>- 并行通信时数据的各个位同时传送，可以字或字节为单位并行进行。
>
>- 并行传输的数据宽度可以是１～１２８位，甚至更宽。

**缺点**

>- 数据有多少位就需要多少根传输线，所以在位数多、传输距离远时，通信线路复杂，用的通信数据线较多，因此传输的成本比较高。
>- 抗干扰能力差。

##### 1.2串行通信

UART（Universal Asynchronous Receiver/Transmitter，即通用异步收发器）串行通信是单片机最常用的一种通信技术，通常用于单片机和电脑之间以及单片机和单片机之间的通信。

###### 1.2.1 串行通信的初步认识

串行通信，就如同一条车道，一次只能一辆车过去，如果一个0xfe这样一个字节的数据要传输过去的话，假如低位在前高位在后，那发送方式就是0-1-1-1-1-1-1-1-1，一位一位的发送出去的，要发送8次才能发送完一个字节。


<img src="..\imgs\单片机间UART.jpg"  alt="单片机之间UART通信示意图" />

图1.2 单片机之间UART通信示意图
图中，GND表示单片机系统电源的参考地，TXD是串行发送引脚，RXD是串行接收引脚。两个单片机之间要通信，首先电源基准得一样，所以我们要把两个单片机的GND相互连起来，然后单片机1的TXD引脚接到单片机2的RXD引脚上，即此路为单片机1发送而单片机2接收的通道，单片机1的RXD引脚接到单片机2的TXD引脚上，即此路为单片机2发送而单片机2接收的通道。这个示意图就体现了两个单片机各自收发信息的过程。
当单片机1想给单片机2发送数据时，比如发送一个0xE4这个数据，用二进制形式表示就是0b11100100，在UART通信过程中，是低位先发，高位后发的原则，那么就让TXD首先拉低电平，持续一段时间，发送一位0，然后继续拉低，再持续一段时间，又发送了一位0，然后拉高电平，持续一段时间，发了一位1......一直到把8位二进制数字0b11100100全部发送完毕。这里就牵扯到了一个问题，就是持续的这“一段时间”到底是多久？从这里引入我们通信中的另外重要概念——波特率，也叫做比特率。
波特率就是发送一位二进制数据的速率，习惯上用baud表示，即我们发送一位数据的持续时间=1/baud。在通信之前，单片机1和单片机2首先都要明确的约定好他们之间的通信波特率，必须保持一致，收发双方才能正常实现通信，这一点大家一定要记清楚。
约定好速度后，我们还要考虑第二个问题，数据什么时候是起始，什么时候是结束呢？不管是提前接收还是延迟接收，数据都会接收错误。在UART串行通信的时候，一个字节是8位，规定当没有通信信号发生时，通信线路保持高电平，当要发送数据之前，先发一位0表示起始位，然后发送8位数据位，数据位是先低后高的顺序，数据位发完后再发一位1表示停止位。这样本来要发送一个字节8位数据，而实际上我们一共发送了10位，多出来的两位其中一位起始位，一位停止位。而接收方呢，原本一直保持的高电平，一旦检测到来了一位低电平，那就知道了要开始准备接收数据了，接收到8位数据位后，然后检测到停止位，再准备下一个数据的接收了。我们图示看一下，如图1-2所示。
<img src="..\imgs\串口数据发送示意图.jpg"  alt="串口数据发送示意图" />

图1-2 串口数据发送示意图
    如图1-2串口数据发送示意图，实际上是一个时域示意图，就是信号随着时间变化的对应关系。比如在单片机的发送引脚上，左边的是先发生的，右边的是后发生的，数据位的切换时间就是波特率分之一秒，如果能够理解时域的概念，后边很多通信的时序图就很容易理解了。

###### 1.2.2 USB转串口通信

随着技术的发展，工业上还有RS232串口通信的大量使用，但是商业技术的应用上，已经慢慢的使用USB转UART技术取代了RS232串口，绝大多数笔记本电脑已经没有串口这个东西了，那我们要实现单片机和电脑之间的通信该如何办呢？
我们只需要在我们电路上添加一个USB转串口芯片，就可以成功实现USB通信协议和标准UART串行通信协议的转换



CH340G这个电路很简单，把电源电路，晶振电路接好后，6脚和7脚的UD+和UD-分别接USB口的2个数据引脚上去，3脚和4脚接到了我们单片机的TXD和RXD上去。
CH340G的电路里2脚位置加了个4148的二极管，是一个小技巧。因为我们的STC89C52RC这个单片机下载程序需要冷启动，就是先点下载后上电，上电瞬间单片机会先检测需要不需要下载程序。虽然单片机的VCC是由开关来控制，但是由于CH340G的2脚是输出引脚，如果没有此二极管，开关后级单片机在断电的情况下，CH340G的2脚和单片机的P3.0（即RXD）引脚连在一起，有电流会通过这个引脚流入后级电路并且给后级的电容充电，造成后级有一定幅度的电压，这个电压值虽然只有两三伏左右，但是可能会影响到我们的冷启动。加了二极管后，一方面不影响通信，另外一个方面还可以消除这种问题。这个地方可以暂时作为了解，大家如果自己做这块电路，可以参考一下。

###### **1.3 IO口模拟UART串口通信**

为了让大家充分理解UART串口通信的原理，我们先用常用的STC89C52来做模拟，用他的3.0和P3.1这两个引脚当做IO口来进行模拟实际串口通信的过程，原理搞懂后，我们再使用寄存器配置实现串口通信过程。
对于UART串口波特率，常用的值是1200、2400、4800、9600、14400、19200、28800、38400、57600、115200、128000、256000等速率。IO口模拟UART串行通信程序是一个简单的演示程序，我们使用串口调试助手下发一个数据，数据加1后，再自动返回。波特率是我们程序设定好的选择，我们程序中让一个数据位持续时间是1/9600秒，那这个地方选择波特率就是选9600，校验位选N，数据位8，停止位1。
串口调试助手的实质就是我们利用电脑上的UART通信接口，通过这个UART接口发送数据给我们的单片机，也可以把我们的单片机发送的数据接收到这个调试助手界面上。
因为初次接触通信方面的技术，所以我对这个程序进行一下解释，大家可以边看我的解释边看程序，把底层原理先彻底弄懂。
变量定义部分就不用说了，直接看main主函数。首先是对通信的波特率的设定，在这里我们配置的波特率是9600，那么串口调试助手也得是9600。配置波特率的时候，我们用的是定时器0的模式2。模式2中，不再是TH0代表高8位，TL0代表低8位了，而只有TL0在进行计数了。当TL0溢出后，不仅仅会让TF0变1，而且还会将TH0中的内容重新自动装到TL0中。这样有一个好处，我们可以把我们想要的定时器初值提前存在TH0中，当TL0溢出后，TH0自动把初值就重新送入TL0了，全自动的，不需要程序上再给TL0重新赋值了，配置方式很简单，大家可以自己看下程序并且计算一下初值。
波特率设置好以后，打开中断，然后等待接收串口调试助手下发的数据。接收数据的时候，首先要进行低电平检测 while (PIN_RXD)，若没有低电平则说明没有数据，一旦检测到低电平，就进入启动接收函数StartRXD()。接收函数最开始启动半个波特率周期，初学可能这里不是很明白。大家回头看一下我们的图1-2里边的串口数据示意图，信号在数据位电平变化的时候去读，因为时序上的误差以及信号稳定性的问题很容易读错数据，所以我们希望在信号最稳定的时候去读数据。除了信号变化的那个沿的位置外，其他位置都很稳定，那么我们现在就约定在信号中间位置去读取电平状态，这样能够保证我们信号读的是对的。
一旦读到了起始信号，我们就把当前状态设定成接受状态，并且打开定时器中断，第一次是半个周期进入中断后，对起始位进行二次判断一下，确认一下起始位是低电平，而不是一个干扰信号。以后每经过9600分之一秒进入一次中断，并且把这个引脚的状态读到RxdBuf里边。等待接收完毕之后，我们再把这个RxdBuf加1，再通过TXD引脚发送出去，同样需要先发一位起始位，然后发8个数据位，再发结束位，发送完毕后，程序运行到while (PIN_RXD)，等待第二轮信号接收的开始。

```c
#include <reg52.h>
sbit PIN_RXD = P3^0;  	//接收引脚定义
sbit PIN_TXD = P3^1;  	//发送引脚定义
bit RxdOrTxd = 0;  	//指示当前状态为接收还是发送
bit RxdEnd = 0;    	//接收结束标志
bit TxdEnd = 0;    	//发送结束标志
unsigned char RxdBuf = 0;  //接收缓冲器
unsigned char TxdBuf = 0;  //发送缓冲器
void ConfigUART(unsigned int baud);
void StartTXD(unsigned char dat);
void StartRXD();
void main ()
{
    ConfigUART(9600);  //配置波特率为9600
    EA = 1;            //开总中断

    while(1)
    {
        while (PIN_RXD);    //等待接收引脚出现低电平，即起始位
        StartRXD();         //启动接收
        while (!RxdEnd);    //等待接收完成
        StartTXD(RxdBuf+1); //接收到的数据+1后，发送回去
        while (!TxdEnd);    //等待发送完成
    }

}
void ConfigUART(unsigned int baud)  //串口配置函数，baud为波特率
{
    TMOD &= 0xF0;   //清零T0的控制位
    TMOD |= 0x02;   //配置T0为模式2
    TH0 = 256 - (11059200/12) / baud;  //计算T0重载值
}
void StartRXD()   //启动串行接收
{
    TL0 = 256 - ((256-TH0) >> 1);  //接收启动时的T0定时为半个波特率周期
    ET0 = 1;        //使能T0中断
    TR0 = 1;        //启动T0
    RxdEnd = 0;     //清零接收结束标志
    RxdOrTxd = 0;   //设置当前状态为接收
}
void StartTXD(unsigned char dat)  //启动串行发送，dat为待发送字节数据
{
    TxdBuf = dat;   //待发送数据保存到发送缓冲器
    TL0 = TH0;      //T0计数初值为重载值
    ET0 = 1;        //使能T0中断
    TR0 = 1;        //启动T0
    PIN_TXD = 0;    //发送起始位
    TxdEnd = 0;     //清零发送结束标志
    RxdOrTxd = 1;   //设置当前状态为发送
}
void InterruptTimer0() interrupt 1  //T0中断服务函数，处理串行发送和接收
{
    static unsigned char cnt = 0;   //bit计数器，记录当前正在处理的位
    if (RxdOrTxd)  //串行发送处理
    {
        cnt++;
        if (cnt <= 8)  //低位在先依次发送8bit数据位
        {
            PIN_TXD = TxdBuf & 0x01;
            TxdBuf >>= 1;
        }
        else if (cnt == 9)  //发送停止位
        {
            PIN_TXD = 1;
        }
        else  //发送结束
        {
            cnt = 0;    //复位bit计数器
            TR0 = 0;    //关闭T0
            TxdEnd = 1; //置发送结束标志
        }
    }
    else  //串行接收处理
    {
        if (cnt == 0)     //处理起始位
        {
            if (!PIN_RXD) //起始位为0时，清零接收缓冲器，准备接收数据位
            {
                RxdBuf = 0;
                cnt++;
            }
            else          //起始位不为0时，中止接收
            {
                TR0 = 0;  //关闭T0
            }
        }
        else if (cnt <= 8)   //处理8位数据位
        {
            RxdBuf >>= 1;    //低位在先，所以将之前接收的位向右移
            if (PIN_RXD)     //接收脚为1时，缓冲器最高位置1；为0时不处理即仍保持移位后的0
            {
                RxdBuf |= 0x80;
            }
            cnt++;
        }
        else  //停止位处理
        {
            cnt = 0;         //复位bit计数器
            TR0 = 0;         //关闭T0
            if (PIN_RXD)     //停止位为1时，方能认为数据有效
            {
                RxdEnd = 1;  //置接收结束标志
            }
        }
    }
}
```

### 三、交互内容

既然是机器之间交互，那么最容易让其理解的莫非二进制文件了，这也是软件在最后被编译成二进制文件去执行的原因。

但是在交互过程中，因为需要人为设计内容，设计交互的内容控制的行为，所以这里的内容设计往往并不会以最有效的形式。

###### 控制与数据传送

用位直接操控机械的控制命令->预估命令个数，匹配对应控制位

索引的建立，针对大文件或者需要较长处理时间的操作，先确立索引，再执行。

数据的解析：将被压缩、打包信息解读出来





[返回](../experience.html)