# Flash划分三段

# 查看芯片资源

![](Resource\embaddedFlashMenory.png)

![](Resource\STM32H750MermoryOrganization.png)

The embedded Flash memory supports read-while-write operations provided the read and 
write operations target different banks. Similarly read-while-read operations are supported 
when two read operations target different banks.

这里可以看到，芯片本身是直接支持两个不同bank独立读写的，但是咱们用的是H750，只有一个bank，而且只有一个sector0。 所以还好看看别的信息

![](Resource\FlashReadPipeline.png)

![](Resource\flashWaitStatesProgramm.png)

*这里需要注意一下，FLASH的时钟最快为225M，而系统走的时钟是480M，分频到AXI总线上的时钟也有240M，可能会导致一些问题的出现。*

查阅文档得出，FlASH的最小擦除单位是一个扇区（sector），而要进行写入操作时，就必须先对该扇区进行擦除（*将所有单位置一，写只能将单位置零，所以写之前要擦除*），所以直接将STM32H750vb芯片的**内置flash**划分为三段是不可行的。



# 将FLASH程序加载到SRAM中执行

## 整理内存关系

### 需要移植的数据

先知道我们的程序产生那些数据，存放在那些地方，知道这个之后，更改数据存放位置就安然无忧了。

查看keil5编译文件中的 .map 文件，就可以知道，产生的数据主体： RO Data, RW Data, Code,  ZI Data。在常规烧写过程中，除了ZI Data因为是在运行中产生，其他数据都被存放在FLASH中。 

- **CODE：**代码区，指程序中代码即函数体的大小，注意程序中未使用的函数也会算在CODE中，也即会占用FLASH空间，因此不用的函数最好删除掉，以免占用过多FLASH空间；
- **RO-DATA：**RO就是只读的意思，程序中只读的变量（也就是带Const的）和已初始化的字符串等；
- **RW-DATA：**特指已初始化的可读可写全局/静态变量；
- **ZI-DATA：**未初始化的可读可写全局/静态变量，注意初始化为0也算做未初始化，用到的堆空间和栈空间也会被算入这里面；

![](Resource\程序的存储态和运行态.png)

因为一旦对flash进行檫写，其中的整个扇区都要被置一，所以我们需要将在运行时仍然处于FLASH中的内容全部移植到SRAM中。

### 移植地址

查看资料，将芯片的内存地址找出来。这样就知道数据具体存放在哪里。

![](Resource\MemoryMap2.png)

![](Resource\MemoryMap3.png)

先看code部分，我们的数据经过烧写程序，是直接下载到 Flash memory bank 1 中的，首地址是0x080000000，我们的目标是将程序加载到首地址为0x000000000的 ITCM 中。

![](Resource\ITCM.png)

如上图所示，只有将程序加载到 ITCM中，才能充分利用芯片480M的主时钟。

### 原来的存放地址

查看 .sct 文件

```
; *************************************************************
; *** Scatter-Loading Description File generated by uVision ***
; *************************************************************

LR_IROM1 0x08000000 0x00020000  {    ; load region size_region
  ER_IROM1 0x08000000 0x00020000  {  ; load address = execution address
   *.o (RESET, +First)
   *(InRoot$$Sections)
   .ANY (+RO)
  }
  RW_IRAM1 0x20000000 0x00020000  {  ; RW data
   .ANY (+RW +ZI)
  }
  RW_IRAM2 0x24000000 0x00080000  {
   .ANY (+RW +ZI)
  }
}
```

***.o (RESET, +First)**其中的RESET代码段主要存储了中断向量表，把他放在flash首地址



## 移植

### 第一步：flash拷贝

1.计算flash内容大小

>查看 .map 文件，flash大小为11.49KB，这里取20kb
>
2. 逐步拷贝到SRAM中

### 第二步：程序跳转

#### 1. SP指针跳转

**这里遇到了很大的问题**，首先程序运行的首地址和预想的0x08000000并不一样，MSP是0x02000000，而PSP是0x00000000。

这里的PSP地址是0x00000000的问题，经过查看M7内核资料，指出两个指针是选一个用的

>The processor uses a full descending stack. This means that the stack pointer holds the address of the last stacked item in memory. When the processor pushes a new item onto the stack, it decrements the stack pointer and then writes the item to the new memory location. The processor implements two stacks, the main stack and the process stack, with a pointer for each held in independent registers
>
>The processor implements two stacks, the main stack and the process stack, with a pointer for each held in independent registers

这也就表明，PSP只是不用而已，不表示它指向了ITCM，虚惊一场啦。

这里注意到一个PC指针，也跟程序的位置有关

>The Program Counter (PC) is register R15. It contains the current program address. On reset, the processor loads the PC with the value of the reset vector, which is at the initial value of the Vector Table Offset Register (VTOR) plus 0x00000004. Bit[0] of the value is loaded into the EPSR T-bit at reset and must be 1.

**这里区别一下PC和SP指针，PC是指向程序运行的，表示当然程序的活动位置，而SP是指向堆栈的，表示数据的活动位置。**

也就是说，我上面在main函数中调用 __get_MSP() 函数，获得当前活动位置，而他在0x20000000，说明SP指向了这里。

![](Resource\M7MemoryBehaviour.png)

这里借用M7文档中的表格来重新申明一下这个位置的作用。

**总结一下，更新程序的话，可以将堆栈指针重新指向初始化地址，复用堆栈。如果不跳转堆栈指针的话，可能空间就不够用啦。**

#### 2. PC指针跳转

![](Resource\CoreRegister.png)

当我们实现一个函数的时候，这个函数最终会占用一段内存，而它的函数名代表的就是这段内存的起始地址。当我们调用这个函数的时候，单片机会将这段内存的首地址（函数名对应的地址）加载到PC寄存器中，从而跳转到这段代码来执行。那么我们也可以利用这个原理，定义一个函数指针，将这个指针指向我们想要跳转的地址，然后调用这个函数，就可以实现程序的跳转了。

```c
#define  APP_ADDR  0x08002000   //应用程序首地址定义 
typedef void (*APP_FUNC)(); //函数指针类型定义

APP_FUNC jump2app; //定义一个函数指针

jump2app = ( APP_FUNC )(APP_ADDR + 4); //给函数指针赋值
jump2app(); //调用函数指针，实现程序跳转
```

上面的代码实现了我们要的跳转功能，但是为什么要跳转到（APP_ADDR + 4） 这个地址，而不是APP_ADDR 呢？

　　首先我们要了解主控芯片的启动过程。以STM32为例，在芯片上电的时候，**首先会从内存地址位0x0800 0000(由启动模式决定)的地方加载栈顶地址（4字节），从0x0800 0004的地方加载程序复位地址（4字节），然后跳转到对应的复位地址去执行。**

　　所以上面的程序会中，jump2app这个函数指针的地址为（APP_ADDR + 4），调用这个函数指针的时候，芯片内核会自动跳转到这个指针指向的内存地址，也即是应用程序的复位地址。

PC指针直接存放在内核寄存器中，可以读取寄存器直接获得

```c
//PC在系统里的位置是r15，这里的__ASM("pc")也可以写成__ASM("r15")
register uint32_t __regPC     __ASM("pc");
```



#### 完整程序

```c
#define APP_ADDR 0x08002000 //应用程序首地址定义 
typedef void (*APP_FUNC)(); //函数指针类型定义/**
  * @brief
  * @param
  * @retval
  */
__asm void MSR_MSP(uint32_t addr)
{
    MSR MSP, r0
    BX r14;
}


/**
  * @brief
  * @param
  * @retval
  */
void run_app(uint32_t app_addr)
{
    uint32_t reset_addr = 0;
    APP_FUNC jump2app;
    
    /* 跳转之前关闭相应的中断 */
    NVIC_DisableIRQ(SysTick_IRQn);
    NVIC_DisableIRQ(LPUART_IRQ);
    
    /* 栈顶地址是否合法(这里sram大小为8k) */
    if(((*(uint32_t *)app_addr)&0x2FFFE000) == 0x20000000)
    {
        /* 设置栈指针 */
        MSR_MSP(app_addr);
        /* 获取复位地址 */
        reset_addr = *(uint32_t *)(app_addr+4);
        jump2app = ( APP_FUNC )reset_addr;
        jump2app();
    }
    else
    {
        printf("APP Not Found!\n");
    }
}
```

#### 3. 中断向量表

```c
 SCB->VTOR = address
```







![](Resource\FLASH操作.png)







# 过程排查

## PC指针指向问题

通过下面语句获取pc地址，来检测程序在哪里运行

```c
//PC在系统里的位置是r15，这里的__ASM("pc")也可以写成__ASM("r15")
register uint32_t __regPC     __ASM("pc");
```

哦吼，这就搞不懂了，为啥pc指针也指向SRAM呢



# 参考文献

[ARM Cortex-M底层技术(1)—程序在Flash和SRAM的空间分配](https://www.lagou.com/lgeduarticle/12442.html)

[STM32启动过程——启动文件——分析](https://www.cnblogs.com/amanlikethis/p/3719529.html)

[M7内核资料](/Resource/DUI0646C_cortex_m7_dgug.pdf)

[基于STM32的简易Bootloader实现](https://www.cnblogs.com/jiuliblog-2016/p/11411887.html)